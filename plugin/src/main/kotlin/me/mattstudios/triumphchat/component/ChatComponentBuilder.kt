package me.mattstudios.triumphchat.component

import me.mattstudios.msg.adventure.AdventureSerializer
import me.mattstudios.msg.base.MessageOptions
import me.mattstudios.msg.base.internal.Format
import me.mattstudios.msg.base.internal.action.HoverMessageAction
import me.mattstudios.msg.base.internal.action.MessageAction
import me.mattstudios.msg.base.internal.action.content.HoverContent
import me.mattstudios.msg.base.internal.color.FlatColor
import me.mattstudios.msg.base.internal.color.MessageColor
import me.mattstudios.msg.base.internal.nodes.MessageNode
import me.mattstudios.msg.base.internal.nodes.TextNode
import me.mattstudios.msg.base.internal.parser.MarkdownParser
import me.mattstudios.triumphchat.config.bean.objects.FormatDisplay
import me.mattstudios.triumphchat.config.bean.objects.elements.ClickData
import me.mattstudios.triumphchat.func.GLOBAL_MESSAGE
import me.mattstudios.triumphchat.func.parsePAPI
import net.kyori.adventure.text.Component
import org.bukkit.entity.Player

class ChatComponentBuilder {

    private val finalNodes = mutableListOf<MessageNode>()
    private val currentNodes = mutableListOf<MessageNode>()

    /**
     * Appends a string, hover, and click
     */
    fun append(
        text: String,
        hover: List<String>? = null,
        click: ClickData? = null,
        formats: Set<Format>,
        player: Player
    ): ChatComponentBuilder {
        return append(text.parsePAPI(player), hover, click, player, formats)
    }

    /**
     * Appends specifically message nodes generated by the message lib
     */
    fun append(
        nodes: List<MessageNode>,
        hover: List<String>? = null,
        click: ClickData? = null,
        player: Player
    ): ChatComponentBuilder {
        currentNodes.addAll(nodes)
        hover?.let { addHover(it.joinToString("\\n") { text -> text.parsePAPI(player) }) }
        click?.let { addClick(it, player) }
        return this
    }

    /**
     * Appends a config component
     */
    fun append(display: FormatDisplay, player: Player): ChatComponentBuilder {
        return append(display.text, display.hover, display.click, player)
    }

    /**
     * Creates the final Kyori component
     */
    fun build(): Component {
        save()
        return AdventureSerializer.toComponent(finalNodes)
    }

    /**
     * Appends a normal text by generating it's nodes from the lib, required to parse markdown from the config
     */
    private fun append(
        message: String,
        hover: List<String>? = null,
        click: ClickData? = null,
        player: Player,
        formats: Set<Format> = Format.ALL,
        defaultColor: MessageColor = FlatColor("white")
    ): ChatComponentBuilder {
        save()
        return append(
            MarkdownParser(
                MessageOptions.builder(formats).setDefaultColor(defaultColor).build()
            ).parse(message),
            hover,
            click,
            player
        )
    }

    /**
     * Appends a string, hover, and click
     */
    private fun append(
        text: String,
        hover: List<String>? = null,
        click: ClickData? = null,
        player: Player
    ): ChatComponentBuilder {
        return append(text.parsePAPI(player), hover, click, Format.ALL, player)
    }

    /**
     * Adds hover action to the current nodes
     */
    private fun addHover(hover: String) {
        if (hover.isEmpty()) return
        addAction(HoverMessageAction(HoverContent.showText(GLOBAL_MESSAGE.parseToNodes(hover))))
    }

    /**
     * Adds a click action to the current nodes
     */
    private fun addClick(click: ClickData, player: Player) {
        var value = click.value
        /*val formatType = click.getFormat()

        if (formatType == null || value == null) return

        if (!value.startsWith('/')) value = "/$value"
        addAction(ClickMessageAction(formatType, value.parsePAPI(player)))*/
    }

    /**
     * Adds the action to all current nodes
     */
    private fun addAction(action: MessageAction) {
        currentNodes.filterIsInstance(TextNode::class.java)
                .filter { it.actions == null || it.actions?.filterIsInstance(action.javaClass)?.isEmpty() == true }
                .forEach {
                    addAction(it, action)
                }
    }

    /**
     * Adds a action to the nodes
     */
    private fun addAction(node: TextNode, action: MessageAction) {
        if (node.actions == null) {
            node.actions = mutableListOf(action)
            return
        }

        node.actions?.add(action)
    }

    /**
     * Saves the current nodes into the final nodes so the next append won't be affected
     */
    private fun save() {
        if (currentNodes.isEmpty()) return
        finalNodes.addAll(currentNodes.toList())
        currentNodes.clear()
    }

}