package me.mattstudios.triumphchat.component

import me.mattstudios.msg.adventure.AdventureSerializer
import me.mattstudios.msg.base.internal.action.ClickMessageAction
import me.mattstudios.msg.base.internal.action.HoverMessageAction
import me.mattstudios.msg.base.internal.action.MessageAction
import me.mattstudios.msg.base.internal.action.content.HoverContent
import me.mattstudios.msg.base.internal.nodes.MessageNode
import me.mattstudios.msg.base.internal.nodes.TextNode
import me.mattstudios.triumphchat.config.bean.objects.FormatDisplay
import me.mattstudios.triumphchat.config.bean.objects.elements.ClickData
import me.mattstudios.triumphchat.func.parseMarkdown
import me.mattstudios.triumphchat.func.parsePAPI
import net.kyori.adventure.text.Component
import org.bukkit.entity.Player

/**
 * This is likely not final, until I figure how I would make this using adventure's builder instead
 * Issues are because of how I handle the extensions
 */
class ComponentBuilder {

    private val finalNodes = mutableListOf<MessageNode>()
    private val currentNodes = mutableListOf<MessageNode>()

    /**
     * Appends a string, hover, and click
     */
    fun append(
        text: String,
        hover: List<String>? = null,
        click: ClickData? = null,
        player: Player
    ): ComponentBuilder {
        return append(text.parsePAPI(player).parseMarkdown(), hover, click, player)
    }

    /**
     * Appends specifically message nodes generated by the message lib
     */
    fun append(
        nodes: List<MessageNode>,
        hover: List<String>? = null,
        click: ClickData? = null,
        player: Player
    ): ComponentBuilder {
        currentNodes.addAll(nodes)
        hover?.let { addHover(it.joinToString("\\n") { text -> text.parsePAPI(player) }) }
        click?.let { addClick(it, player) }
        return this
    }

    /**
     * Appends a config component
     */
    fun append(display: FormatDisplay, player: Player): ComponentBuilder {
        return append(display.text, display.hover, display.click, player)
    }

    /**
     * Creates the final Kyori component
     */
    fun build(): Component {
        save()
        return AdventureSerializer.toComponent(finalNodes)
    }

    /**
     * Adds hover action to the current nodes
     */
    private fun addHover(hover: String) {
        if (hover.isEmpty()) return
        addAction(HoverMessageAction(HoverContent.showText(hover.parseMarkdown())))
    }

    /**
     * Adds a click action to the current nodes
     */
    private fun addClick(click: ClickData, player: Player) {
        with(click) {
            if (isEmpty) return
            addAction(ClickMessageAction(action, finalValue.parsePAPI(player)))
        }
    }

    /**
     * Adds the action to all current nodes
     */
    private fun addAction(action: MessageAction) {
        currentNodes.filterIsInstance(TextNode::class.java)
                .filter { it.actions == null || it.actions?.filterIsInstance(action.javaClass)?.isEmpty() == true }
                .forEach {
                    addAction(it, action)
                }
    }

    /**
     * Adds a action to the nodes
     */
    private fun addAction(node: TextNode, action: MessageAction) {
        if (node.actions == null) {
            node.actions = mutableListOf(action)
            return
        }

        node.actions?.add(action)
    }

    /**
     * Saves the current nodes into the final nodes so the next append won't be affected
     */
    private fun save() {
        if (currentNodes.isEmpty()) return
        finalNodes.addAll(currentNodes.toList())
        currentNodes.clear()
    }

}